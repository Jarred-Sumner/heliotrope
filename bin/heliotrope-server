#!/usr/bin/env ruby
# encoding: UTF-8

require 'rubygems'
require 'json'
require 'trollop'
require 'sinatra/base'
require 'whistlepig'
require "heliotrope"
require 'cgi'
require 'rack'

class Set
  ## apparently we're going to have to do this the hard way
  def to_json(*a); to_a.to_json(*a) end
end

class HeliotropeServer < Sinatra::Base
  def initialize index, store
    @index = index
    @store = store
    @search_state = [] # keep this around for optimization purposes
    super()
  end

  helpers do
    include Rack::Utils
  end

  get "/" do
    redirect "/search?q=~inbox"
  end

  class RequestError < StandardError; end

  error RequestError do
    e = request.env['sinatra.error']
    "error: " + e.message
  end

  DEFAULT_SEARCH_PAGE_SIZE = 20
  MAX_SEARCH_PAGE_SIZE = 300

  post "/message" do
    content_type :json

    begin
      rawbody = params["message"] or raise RequestError, "need a message"
      rawbody.force_encoding "binary" if rawbody.respond_to?(:force_encoding) # sigh...

      message = Heliotrope::Message.new(rawbody).parse!

      if @index.contains_msgid? message.msgid
        { :response => :ok, :status => :seen }
      else
        loc = @store.add rawbody
        doc_id, thread_id = @index.add_message message, %w(unread), %w(inbox), :loc => loc
        { :response => :ok, :status => :unseen, :doc_id => doc_id, :thread_id => thread_id }
      end
    rescue Heliotrope::InvalidMessageError => e
      { :response => :error, :error_message => e.message }
    end.to_json
  end

  def get_search_results
    ## work around a rack (?) bug where quotes are omitted in queries like "hello bob"
    query = if env["rack.request.query_string"] =~ /\bq=(.+?)(&|$)/
      CGI.unescape $1
    else
      params["q"]
    end

    raise RequestError, "need a query" unless query
    start = (params["start"] || 0).to_i
    num = (params["num"] || DEFAULT_SEARCH_PAGE_SIZE).to_i
    num = DEFAULT_SEARCH_PAGE_SIZE if num <= 0
    num = [num, MAX_SEARCH_PAGE_SIZE].min

    query = Heliotrope::Query.new "body", query
    startt = Time.now
    continued = false
    results = if @search_state == [query.parsed_query_s, start]
      continued = true
      @index.get_some_results num
    else
      @index.set_query query
      @index.get_some_results(start + num)[start, num]
    end
    elapsed = Time.now - startt

    ## remove this field from the results because it's not useful and can be large
    results.each { |r| r.delete :structure }

    @search_state = [query.parsed_query_s, start + num]

    [query, results, { :start => start, :num => num, :elapsed => elapsed, :continued => continued }]
  end

  get "/search.json" do
    content_type :json
    query, results, info = get_search_results

    results.to_json
  end

  get "/search" do
    content_type :html

    begin
      query, results, info = get_search_results
      start, num = info[:start], info[:num]
      nav = %{<div style="padding-top: 1em">}
      if start > 0
        nav += link_to_search(query.original_query_s, "<< top", 0, num) + "|" + link_to_search(query.original_query_s, "<< previous", [start - num, 0].max, num)
      end
      if (start > 0) && (results.size == num)
        nav += "|"
      end
      if results.size == num
        nav += link_to_search(query.original_query_s, "next >>", start + num, num)
      end
      nav += "</div>"

      header("Search: #{query.original_query_s}", query.original_query_s) +
        "<div>Parsed query: #{escape_html query.parsed_query_s}</div>" +
        "<div>Search took #{sprintf '%.2f', info[:elapsed]}s and #{info[:continued] ? 'was' : 'was NOT'} continued</div>" +
        "#{nav}<table>" +
        results.map { |r| threadinfo_to_html r }.join +
        "</table>#{nav}" + footer

    rescue Heliotrope::Query::ParseError => e
      raise RequestError, "can't parse query: #{e.message}"
    end
  end

  get "/thread/:thread_id.json" do |thread_id|
    content_type :json
    messageinfos = get_thread_summary thread_id
    messageinfos.to_json
  end

  get "/thread/:thread_id" do |thread_id|
    content_type :html

    thread_id = thread_id.to_i
    messageinfos = get_thread_summary thread_id
    first = messageinfos.find { |mi, level| mi[:subject] }[0]

    header("Thread: " + first[:subject]) +
      messageinfos.map do |mi, level|
        %{<div style="padding-left: #{level}em">} +
          messageinfo_to_html(mi) +
          "</div>"
      end.join +
      footer
  end

  def get_thread_summary thread_id
    @index.load_thread_messageinfos(thread_id) or raise RequestError, "can't find thread #{thread_id.inspect}"
  end

  get "/message/:message_id.json" do |message_id|
    content_type :json
    message_id = message_id.to_i
    messageinfo = get_message_summary message_id
    message = load_actual_message messageinfo[:loc]

    message.to_json(message_id, params["mime_type_pref"] || "text/html")
  end

  get "/message/:message_id" do |message_id|
    content_type :html
    message_id = message_id.to_i
    raise RequestError, "invalid message id" unless message_id > 0

    message = get_message_summary message_id
    raise RequestError, "invalid message id" unless message

    begin
      threadinfo = @index.load_threadinfo(message[:thread_id])
      docids = threadinfo[:structure].flatten
      idx = docids.index(message_id) + 1
      idx += 1 while(docids[idx] && (docids[idx] < 0))
      header(message[:subject]) + message_to_html(message, docids[idx]) + footer
    rescue Heliotrope::InvalidMessageError => e
      raise RequestError, "can't parse message #{message_id.inspect}: #{e.message}"
    end
  end

  def get_message_summary message_id
    @index.load_messageinfo(message_id) or raise RequestError, "can't find message #{message_id.inspect}"
  end

  get "/message/:message_id/part/:part_id" do |message_id, part_id|
    message = get_message_summary message_id
    part_id = part_id.to_i

    begin
      m = load_actual_message message[:loc]
      parts = m.mime_parts "text/html"

      raise RequestError, "can't find that part" unless part_id >= 0 && part_id <= parts.size
      type, fn, id, content = parts[part_id]
      if type =~ /^(\S+?);/
        type = $1
      end
      content_type type
      response['Content-Disposition'] = (type =~ /^(text|image)\// ? "inline" : "attachment")
      response['Content-Disposition'] << %{; filename="#{fn}"} if fn
      content
    rescue Heliotrope::InvalidMessageError => e
      raise RequestError, "can't parse message #{message_id.inspect}: #{e.message}"
    end
  end

  get "/message/:message_id/raw" do |message_id|
    content_type :text
    message = get_message_summary message_id
    @store.read message[:loc]
  end

  get "/labels" do
    content_type :json
    @index.all_labels.to_json
  end

  post "/labels/prune" do
    content_type :json
    @index.prune_labels!
    @index.all_labels.to_json
  end

private

  def load_actual_message offset
    rawbody = @store.read offset
    Heliotrope::Message.new(rawbody).parse!
  end

  def message_to_html message, next_messageid
    mid = message[:message_id]
    m = load_actual_message message[:loc]
    parts = m.mime_parts "text/html"

    ## build up the cid pointers for internal content
    cids = {}
    parts.each_with_index { |(type, fn, id, content), i| cids[id] = i if id }

    s = "<div>#{link_to_threadview message[:thread_id], "<< back to thread"}"
    s += " | #{link_to_messageview next_messageid, "next message in thread >>"}" if next_messageid
    s += "</div>"
    s += %{<div style="padding-top: 1em">From: #{link_to_search m.from.email.downcase, m.from}</div>}
    s += "<div>To: #{m.to.map { |p| link_to_search p.email.downcase, p }.join(", ")}</div>"
    s += "<div>Cc: #{m.cc.map { |p| link_to_search p.email.downcase, p }.join(", ")}</div>" unless m.cc.empty?
    s += "<div>Bcc: #{m.bcc.map { |p| link_to_search p.email.downcase, p }.join(", ")}</div>" unless m.bcc.empty?
    s += "<div>Date: #{Time.at m.date}</div>"
    s += "<div>Subject: #{escape_html m.subject}</div>"

    parts.each_with_index do |(type, fn, id, content), i|
      s += %{<div style="padding-top: 1em">}
      if fn
        s += link_to_attachment mid, i, "[attachment: #{fn} (#{type})]"
        if type =~ /^image\// # show a preview
          s += inline_image(mid, i)
        end
      else
        s += make_html type, content, mid, cids
      end
    end

    s += "<div>" + link_to_raw(mid, "(view raw)") + "</div>"

    #@index.update_message_state(message[:message_id], (message[:state] - ["unread"]))
    s
  end

  ## this whole thing seems pretty dangerous...
  def make_html type, content, message_id, cids
    case type
    when /^text\/html/; cids.inject(content) { |c, (k, v)| c.gsub("cid:#{k}", inline_image_link(message_id, v)) }
    when /^text\/plain/; escape_html(content).gsub("\n", "<br/>")
    else escape_html(content)
    end
  end

  MAX_PARTICIPANT_WIDTH = 40
  MAX_SUBJECT_WIDTH = 80

  def threadinfo_to_html thread
    participants = thread[:participants][0, 3].map do |v|
      p = Heliotrope::Person.from_string(v)
      link_to_search p.email.downcase, p.display_name
    end.join(", ")

    size = thread[:size]
    labels = (thread[:labels] - Heliotrope::Index::MESSAGE_STATE).map do |l|
      link_to_search "~#{l}", "+#{l}"
    end.join(" ")

    subject = link_to_threadview thread[:thread_id], thread[:subject][0, MAX_SUBJECT_WIDTH]
    snippet = (thread[:snippet] || "?") # [0, MAX_SUBJECT_WIDTH - thread[:subject].size]

    date = escape_html Time.at(thread[:date]).strftime("%Y/%m/%d %H:%M")

    flags = escape_html(
      (thread[:state].include?("starred") ? "*" : " ") +
      (thread[:state].include?("unread") ? "N" : " ") +
      (thread[:state].include?("attachment") ? "@" : " ") +
      (thread[:state].include?("signed") ? "S" : " ") +
      (thread[:state].include?("encrypted") ? "E" : " ")
    )

    <<-EOS
<tr>
  <td>#{flags}</td>
  <td><div class="participants">#{participants}</div></td>
  <td>#{size}</td>
  <td><div class="description">#{labels} #{subject} #{escape_html snippet}</div></td>
  <td>#{date}</td>
</tr>
    EOS
  end

  def messageinfo_to_html message
    if message[:type] == "fake" # fake root
      "<td>(an unreceived message)</td>"
    else
      from = Heliotrope::Person.from_string message[:from]
      flags =
        (message[:state].include?("starred") ? "*" : " ") +
        (message[:state].include?("unread") ? "N" : " ") +
        (message[:state].include?("attachment") ? "@" : " ") +
        (message[:state].include?("signed") ? "S" : " ") +
        (message[:state].include?("encrypted") ? "E" : " ")
      date = escape_html Time.at(message[:date]).strftime("%Y/%m/%d %H:%M")
      subject = link_to_messageview message[:message_id], message[:subject]
      snippet = message[:snippet][0, MAX_SUBJECT_WIDTH - message[:subject].size]

      <<-EOS
  <span>#{flags}</span>
  <span>#{link_to_search from.email.downcase, from.display_name}</span>
  <span>#{link_to_messageview message[:message_id], message[:subject]}</span>
  <span>#{escape_html snippet} ...</span>
  <span>#{date}</span>
      EOS
    end
  end

  def link_to_search query, text, start=0, num=DEFAULT_SEARCH_PAGE_SIZE
    %{<a href="/search?q=#{CGI.escape query}&start=#{start}&num=#{num}">#{escape_html text}</a>}
  end

  def link_to_threadview thread_id, text
    %{<a href="/thread/#{thread_id}">#{escape_html text}</a>}
  end

  def link_to_messageview message_id, text
    %{<a href="/message/#{message_id}">#{escape_html text}</a>}
  end

  def link_to_attachment message_id, part_id, text
    %{<a href="/message/#{message_id}/part/#{part_id}">#{escape_html text}</a>}
  end

  def link_to_raw message_id, text
    %{<a href="/message/#{message_id}/raw">#{escape_html text}</a>}
  end

  def inline_image_link message_id, part_id; "/message/#{message_id}/part/#{part_id}" end
  def inline_image message_id, part_id; %{<img src="#{inline_image_link message_id, part_id}">} end

  def header title, query=""
    title = escape_html title
    <<-EOS
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Heliotrope: #{title}</title>
<meta name="application-name" content="heliotrope">
<style type="text/css">
div.description {
  text-overflow: ellipsis;
  overflow: hidden;
  width: 600px;
}

div.participants {
  overflow: hidden;
  width: 200px;
}

td {
  white-space: nowrap;
}
</style>
</head><body><h1>#{title}</h1>
<div>
<form method="get" action="/search">
  #{link_to_search "~inbox", "[inbox]"}
  Search: <input name="q" size=50 value="#{escape_html query}"/>
  <input type="submit" value="go"/>
  </form></div>
    EOS
  end

  def footer
    "</body></html>"
  end
end

### execution begins here ###

opts = Trollop::options do
  banner <<EOS
Usage: #{$0} [options]

Where options include:
EOS
  opt :host, "Host interface to listen on", :default => "0.0.0.0", :short => "-H"
  opt :port, "Port to listen on", :default => 8042
  opt :dir, "Base directory for all index files", :default => "."
  opt :mode, "Runtime mode", :default => "development"
end

index = Heliotrope::Index.new opts.dir
store = Heliotrope::Store.new File.join(opts.dir, "messages")
server = HeliotropeServer.new index, store

app = if opts.mode == "development"
  Rack::Builder.new do
    use Rack::CommonLogger, $stdout
    use Rack::ShowExceptions
    use Rack::Lint
    run server
  end.to_app
else
  server
end

## yes, we have to do this ourselves here. thanks, rack. no, i don't want to
## run with your crummy set of commandline options.
handler = Rack::Handler.default
trap(:INT) do
  if handler.respond_to?(:shutdown)
    handler.shutdown
  else
    exit
  end
end

handler.run app, :Port => opts.port
