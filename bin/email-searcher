#!/usr/bin/env ruby

require 'rubygems'
require 'trollop'
require 'whistlepig'
require 'console'
require 'console/string'
require 'readline'

require "heliotrope"

FROM_SIZE = 20
MSG_FROM_SIZE = 72
SUBJ_SIZE = 54
DATE_SIZE = 10
TOTAL_WIDTH = 100

PAGE_SIZE = 10

opts = Trollop::options do
  banner <<EOS
Usage: #{$0} [options] <mbox filename>

Where options include:
EOS
  opt :dir, "Base directory for index files", :default => "."
end

mbox_fn = ARGV.shift or Trollop::die "need a filename"
ARGV.empty? or Trollop::die "need exactly one filename"

Console.init_locale!
store = Heliotrope::Store.new opts.dir
#store.debug = true

query = Heliotrope::Query.new "body", "~inbox"

store.set_query query
puts "; counting results..."
num_results = store.count_results
puts "; got #{num_results} results"
results = store.get_some_results PAGE_SIZE

start_idx = 0
while true
  header = "== [#{num_results}] #{query.query.display_slice(0, (TOTAL_WIDTH - 20))} "
  header += "=" * [(TOTAL_WIDTH - header.display_width), 0].max
  puts header

  results.each_with_index do |thread, i|
    participants = thread[:participants].map { |v| Heliotrope::Person.from_string(v).name }.join(",").display_slice(0, FROM_SIZE)
    size = thread[:size]
    labels = (thread[:labels] - Heliotrope::Store::MESSAGE_STATE).map { |l| "+#{l}" }.join(" ")
    subj = (labels + " " + thread[:subject]).display_slice(0, SUBJ_SIZE)
    date = Time.at(thread[:date]).strftime("%Y/%m/%d %H:%M").display_slice(0, DATE_SIZE)
    flags =
      (thread[:state].include?("starred") ? "*" : " ") +
      (thread[:state].include?("unread") ? "N" : " ") +
      (thread[:state].include?("attachment") ? "@" : " ")

    printf "%3d %s %#{FROM_SIZE}s (%3d) %-#{SUBJ_SIZE}s %#{DATE_SIZE}s\n", i + start_idx, flags, participants, size, subj, date
  end
  cmd = Readline.readline "search-command (h for help)> "
  if cmd
    cmd = cmd.strip
    Readline::HISTORY.push cmd unless cmd.empty?
  end

  case cmd
  when "h", "help"
    puts <<EOS

Commands:
                 <enter>: next page of query results
                     top: go to top of query resutls
                   q, ^D: quit
                /<query>: start a new query <query>
                     <#>: view thread <#>
 label <#> [+/-] <label>: add or remove <label> to thread <#>

Searches:
Full query language, including nesting. Labels are specified with ~. There are
built-in labels called "unread", "inbox" and "attachment".

Example queries:

 ~inbox       # show my my inbox
 ruby OR "Bob Jones"
 -~read ~attachment
 ruby (-ruby-talk OR -~read)

EOS
  when "", "cont", "continue"
    start_idx += results.size unless results.size < PAGE_SIZE
    results = store.get_some_results PAGE_SIZE
  when "top"
    start_idx = 0
    store.set_query query
    results = store.get_some_results PAGE_SIZE
  when "q", nil
    puts
    break
  when /^\/(.*)$/ # new query
    begin
      newquery = $1
      ## kinda hacky... downcase everything except ORs
      newquery = newquery.split(/\s+/).map { |x| x == "OR" ? x : x.downcase }.join(" ")
      newquery = Heliotrope::Query.new "body", newquery
      puts "# parsed query is #{newquery.query}"

      query = newquery
      store.set_query query
      puts "; counting results..."
      num_results = store.count_results
      puts "; got #{num_results} results"
      results = store.get_some_results PAGE_SIZE

      start_idx = 0
    rescue Heliotrope::Query::ParseError => e
      puts "Error: #{e.message}"
    end
  when /^label\s+(\d+)\s+([+-]?)(\w+)$/
    tidx = $1.to_i - start_idx

    if tidx < 0 || tidx >= results.size
      puts "unknown thread number; expecting id between #{start_idx} and #{start_idx + results.size}"
      next
    end

    remove = $2 == "-"
    label = $3

    old_labels = results[tidx][:labels]
    new_labels = if remove
      old_labels - [label]
    else
      old_labels + [label]
    end

    thread_id = results[tidx][:thread_id]
    new_labels = store.update_thread_labels thread_id, new_labels
    results[tidx][:labels] = new_labels if new_labels
  when /^(\d+)$/
    tidx = $1.to_i - start_idx

    if tidx < 0 || tidx >= results.size
      puts "unknown thread number; expecting id between #{start_idx} and #{start_idx + results.size}"
      next
    end

    thread_id = results[tidx][:thread_id]
    messageinfos = store.load_thread_messageinfos thread_id
    mid = -1

    while true
      subj = results[tidx][:subject].display_slice(0, TOTAL_WIDTH - 20)
      header = "-- [#{results[tidx][:size]}] \"#{subj}\""
      header += "-" * [(TOTAL_WIDTH - header.display_width), 0].max
      puts header

      message_idx = []
      messageinfos.each.with_index do |(mi, level), idx|
        if mi[:type] == "fake" # fake root
          print(" " * level * 2)
          puts "(an unreceived message)"
        else
          id = message_idx.size
          message_idx[id] = idx
          flags =
            (mi[:state].include?("starred") ? "*" : " ") +
            (mi[:state].include?("unread") ? "N" : " ") +
            (mi[:state].include?("attachment") ? "@" : " ")
          date = Time.at(mi[:date]).strftime("%Y/%m/%d %H:%M").display_slice(0, DATE_SIZE)

          printf "%2d %s ", id, flags
          from = (" " * level * 2) + mi[:from].display_slice(0, MSG_FROM_SIZE)
          printf "%-#{MSG_FROM_SIZE + 10}s %#{DATE_SIZE}s\n", from, date
        end
      end

      cmd = Readline.readline "thread-command (h for help)> "
      unless cmd
        puts
        break
      end

      cmd = cmd.strip
      Readline::HISTORY.push cmd unless cmd.empty?

      case cmd
      when /^(\d*)$/
        midx = if $1.empty?
          mid += 1
          midx = message_idx[mid]
          break unless midx
          midx
        else
          mid = $1.to_i
          midx = message_idx[mid]
          unless midx
            puts "unknown message #{mid}"
            next
          end
          midx
        end

        message, level = messageinfos[midx]

        rawbody = File.open(mbox_fn, "r:BINARY") { |f| Heliotrope::MboxSplitter.new(f).message_at message[:offset] }
        m = Heliotrope::Message.new(rawbody).parse!
        puts "From: #{m.from}"
        puts "To: #{m.to.join(", ")}"
        puts "Cc: #{m.cc.join(", ")}" unless m.cc.empty?
        puts "Bcc: #{m.bcc.join(", ")}" unless m.bcc.empty?
        puts "Date: #{Time.at m.date}"
        puts "Subject: #{m.subject}\n\n"
        m.mime_parts("text/plain").each do |type, fn, content|
          if fn
            puts "\n[attachment (#{type}): #{fn}]"
          else
            puts content
          end
        end
        puts

        new_mstate, new_tstate, new_tlabels = store.update_message_state(message[:message_id], (message[:state] - ["unread"]))
        messageinfos[midx][0][:state] = new_mstate if new_mstate
        results[tidx][:state] = new_tstate if new_tstate
        results[tidx][:labels] = new_tlabels if new_tlabels
      when "q", "quit"
        puts
        break
      when "h", "help"
        puts <<EOS

Commands:
          <#>: view message <#>
      <enter>: view next message
  q, quit, ^D: go back to search mode
EOS
      end
    end
  else
    puts "unknown command. try h for help."
  end
end
